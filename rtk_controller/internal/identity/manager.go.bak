package identity

import (
	"encoding/json"
	"fmt"
	"log"
	"regexp"
	"sort"
	"strings"
	"sync"
	"time"

	"rtk_controller/internal/storage"
	"rtk_controller/pkg/types"
)

// Manager handles device identity management
type Manager struct {
	storage       *storage.IdentityStorage
	detectionRules map[string]*types.DetectionRule
	rulesMutex    sync.RWMutex
	
	// Auto-detection configuration
	autoDetectionEnabled bool
	detectionInterval    time.Duration
	
	// Statistics
	stats      *types.DeviceIdentityStats
	statsMutex sync.RWMutex
}

// NewManager creates a new device identity manager
func NewManager(storage storage.Storage) *Manager {
	identityStorage := storage.NewIdentityStorage(storage)
	
	manager := &Manager{
		storage:              identityStorage,
		detectionRules:       make(map[string]*types.DetectionRule),
		autoDetectionEnabled: true,
		detectionInterval:    5 * time.Minute,
		stats:               &types.DeviceIdentityStats{},
	}
	
	// Load detection rules from storage
	if err := manager.loadDetectionRules(); err != nil {
		log.Printf("Failed to load detection rules: %v", err)
	}
	
	// Initialize default detection rules if none exist
	if len(manager.detectionRules) == 0 {
		manager.initializeDefaultRules()
	}
	
	return manager
}

// Device Identity Management

// SetDeviceIdentity sets or updates a device identity
func (m *Manager) SetDeviceIdentity(identity *types.DeviceIdentity) error {
	identity.LastUpdated = time.Now()
	identity.UpdatedBy = "user"
	
	if err := m.storage.SaveDeviceIdentity(identity); err != nil {
		return fmt.Errorf("failed to save device identity: %w", err)
	}
	
	// Update statistics
	m.updateStats()
	
	return nil
}

// GetDeviceIdentity retrieves a device identity by MAC address
func (m *Manager) GetDeviceIdentity(macAddress string) (*types.DeviceIdentity, error) {
	identity, err := m.storage.GetDeviceIdentity(macAddress)
	if err != nil {
		return nil, fmt.Errorf("failed to get device identity: %w", err)
	}
	
	return identity, nil
}

// GetDeviceFriendlyName retrieves the friendly name for a MAC address
func (m *Manager) GetDeviceFriendlyName(macAddress string) string {
	identity, err := m.GetDeviceIdentity(macAddress)
	if err != nil || identity == nil {
		// Return MAC address if no friendly name is set
		return macAddress
	}
	
	if identity.FriendlyName != "" {
		return identity.FriendlyName
	}
	
	return macAddress
}

// DeleteDeviceIdentity deletes a device identity
func (m *Manager) DeleteDeviceIdentity(macAddress string) error {
	if err := m.storage.DeleteDeviceIdentity(macAddress); err != nil {
		return fmt.Errorf("failed to delete device identity: %w", err)
	}
	
	// Update statistics
	m.updateStats()
	
	return nil
}

// ListDeviceIdentities lists device identities with optional filtering
func (m *Manager) ListDeviceIdentities(filter *types.DeviceIdentityFilter, limit, offset int) ([]*types.DeviceIdentity, int, error) {
	identities, total, err := m.storage.ListDeviceIdentities(filter, limit, offset)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list device identities: %w", err)
	}
	
	return identities, total, nil
}

// Auto-Detection Management

// ProcessDetectionCandidate processes a device for automatic identity detection
func (m *Manager) ProcessDetectionCandidate(candidate *types.DeviceDetectionCandidate) (*types.DeviceIdentity, error) {
	if !m.autoDetectionEnabled {
		return nil, nil
	}
	
	// Check if identity already exists
	existingIdentity, err := m.GetDeviceIdentity(candidate.MacAddress)
	if err == nil && existingIdentity != nil && !existingIdentity.AutoDetected {
		// Don't override manually set identities
		return existingIdentity, nil
	}
	
	// Run detection rules
	matches := m.runDetectionRules(candidate)
	if len(matches) == 0 {
		return nil, nil
	}
	
	// Sort matches by confidence and priority
	sort.Slice(matches, func(i, j int) bool {
		if matches[i].Confidence != matches[j].Confidence {
			return matches[i].Confidence > matches[j].Confidence
		}
		return m.getRulePriority(matches[i].RuleID) > m.getRulePriority(matches[j].RuleID)
	})
	
	// Apply the best match
	bestMatch := matches[0]
	rule := m.detectionRules[bestMatch.RuleID]
	if rule == nil {
		return nil, fmt.Errorf("detection rule not found: %s", bestMatch.RuleID)
	}
	
	// Create or update identity
	identity := &types.DeviceIdentity{
		MacAddress:     candidate.MacAddress,
		AutoDetected:   true,
		DetectionRules: matches,
		Confidence:     bestMatch.Confidence,
		FirstSeen:      candidate.FirstSeen,
		LastSeen:       candidate.LastSeen,
		LastUpdated:    time.Now(),
		UpdatedBy:      "auto_detection",
	}
	
	// Apply detection action
	m.applyDetectionAction(identity, &rule.Action, candidate)
	
	// Save the identity
	if err := m.storage.SaveDeviceIdentity(identity); err != nil {
		return nil, fmt.Errorf("failed to save auto-detected identity: %w", err)
	}
	
	m.updateStats()
	
	return identity, nil
}

// Detection Rules Management

// AddDetectionRule adds a new detection rule
func (m *Manager) AddDetectionRule(rule *types.DetectionRule) error {
	m.rulesMutex.Lock()
	defer m.rulesMutex.Unlock()
	
	rule.CreatedAt = time.Now()
	rule.UpdatedAt = time.Now()
	
	if err := m.storage.SaveDetectionRule(rule); err != nil {
		return fmt.Errorf("failed to save detection rule: %w", err)
	}
	
	m.detectionRules[rule.ID] = rule
	
	return nil
}

// GetDetectionRule retrieves a detection rule by ID
func (m *Manager) GetDetectionRule(ruleID string) (*types.DetectionRule, error) {
	m.rulesMutex.RLock()
	defer m.rulesMutex.RUnlock()
	
	rule, exists := m.detectionRules[ruleID]
	if !exists {
		return nil, fmt.Errorf("detection rule not found: %s", ruleID)
	}
	
	return rule, nil
}

// UpdateDetectionRule updates an existing detection rule
func (m *Manager) UpdateDetectionRule(rule *types.DetectionRule) error {
	m.rulesMutex.Lock()
	defer m.rulesMutex.Unlock()
	
	if _, exists := m.detectionRules[rule.ID]; !exists {
		return fmt.Errorf("detection rule not found: %s", rule.ID)
	}
	
	rule.UpdatedAt = time.Now()
	
	if err := m.storage.SaveDetectionRule(rule); err != nil {
		return fmt.Errorf("failed to update detection rule: %w", err)
	}
	
	m.detectionRules[rule.ID] = rule
	
	return nil
}

// DeleteDetectionRule deletes a detection rule
func (m *Manager) DeleteDetectionRule(ruleID string) error {
	m.rulesMutex.Lock()
	defer m.rulesMutex.Unlock()
	
	if err := m.storage.DeleteDetectionRule(ruleID); err != nil {
		return fmt.Errorf("failed to delete detection rule: %w", err)
	}
	
	delete(m.detectionRules, ruleID)
	
	return nil
}

// ListDetectionRules lists all detection rules
func (m *Manager) ListDetectionRules() ([]*types.DetectionRule, error) {
	m.rulesMutex.RLock()
	defer m.rulesMutex.RUnlock()
	
	rules := make([]*types.DetectionRule, 0, len(m.detectionRules))
	for _, rule := range m.detectionRules {
		rules = append(rules, rule)
	}
	
	// Sort by priority (descending)
	sort.Slice(rules, func(i, j int) bool {
		return rules[i].Priority > rules[j].Priority
	})
	
	return rules, nil
}

// Import/Export Operations

// ImportDeviceIdentities imports device identities from a list
func (m *Manager) ImportDeviceIdentities(entries []*types.IdentityImportEntry, overwrite bool) (int, int, error) {
	imported := 0
	skipped := 0
	
	for _, entry := range entries {
		// Check if identity already exists
		existing, err := m.GetDeviceIdentity(entry.MacAddress)
		if err == nil && existing != nil && !overwrite {
			skipped++
			continue
		}
		
		// Create identity from import entry
		identity := &types.DeviceIdentity{
			MacAddress:   entry.MacAddress,
			FriendlyName: entry.FriendlyName,
			DeviceType:   entry.DeviceType,
			Manufacturer: entry.Manufacturer,
			Model:        entry.Model,
			Location:     entry.Location,
			Owner:        entry.Owner,
			Category:     entry.Category,
			Tags:         entry.Tags,
			Notes:        entry.Notes,
			AutoDetected: false,
			FirstSeen:    time.Now(),
			LastSeen:     time.Now(),
			LastUpdated:  time.Now(),
			UpdatedBy:    "import",
		}
		
		if err := m.storage.SaveDeviceIdentity(identity); err != nil {
			return imported, skipped, fmt.Errorf("failed to import identity for %s: %w", entry.MacAddress, err)
		}
		
		imported++
	}
	
	m.updateStats()
	
	return imported, skipped, nil
}

// ExportDeviceIdentities exports device identities
func (m *Manager) ExportDeviceIdentities(filter *types.DeviceIdentityFilter) ([]*types.IdentityExportEntry, error) {
	identities, _, err := m.storage.ListDeviceIdentities(filter, 0, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to list identities for export: %w", err)
	}
	
	exports := make([]*types.IdentityExportEntry, len(identities))
	for i, identity := range identities {
		exports[i] = &types.IdentityExportEntry{
			MacAddress:   identity.MacAddress,
			FriendlyName: identity.FriendlyName,
			DeviceType:   identity.DeviceType,
			Manufacturer: identity.Manufacturer,
			Model:        identity.Model,
			Location:     identity.Location,
			Owner:        identity.Owner,
			Category:     identity.Category,
			Tags:         identity.Tags,
			AutoDetected: identity.AutoDetected,
			Confidence:   identity.Confidence,
			FirstSeen:    identity.FirstSeen.Format(time.RFC3339),
			LastSeen:     identity.LastSeen.Format(time.RFC3339),
			Notes:        identity.Notes,
		}
	}
	
	return exports, nil
}

// Statistics

// GetStats returns identity statistics
func (m *Manager) GetStats() *types.DeviceIdentityStats {
	m.statsMutex.RLock()
	defer m.statsMutex.RUnlock()
	
	// Return a copy to avoid race conditions
	stats := *m.stats
	return &stats
}

// Configuration

// SetAutoDetectionEnabled enables or disables auto-detection
func (m *Manager) SetAutoDetectionEnabled(enabled bool) {
	m.autoDetectionEnabled = enabled
}

// IsAutoDetectionEnabled returns whether auto-detection is enabled
func (m *Manager) IsAutoDetectionEnabled() bool {
	return m.autoDetectionEnabled
}

// Private helper methods

func (m *Manager) loadDetectionRules() error {
	rules, err := m.storage.ListDetectionRules()
	if err != nil {
		return err
	}
	
	m.rulesMutex.Lock()
	defer m.rulesMutex.Unlock()
	
	for _, rule := range rules {
		m.detectionRules[rule.ID] = rule
	}
	
	return nil
}

func (m *Manager) runDetectionRules(candidate *types.DeviceDetectionCandidate) []types.DetectionRuleMatch {
	m.rulesMutex.RLock()
	defer m.rulesMutex.RUnlock()
	
	var matches []types.DetectionRuleMatch
	
	for _, rule := range m.detectionRules {
		if !rule.Enabled {
			continue
		}
		
		if m.evaluateRule(rule, candidate) {
			match := types.DetectionRuleMatch{
				RuleID:       rule.ID,
				RuleName:     rule.Name,
				MatchedField: "", // Will be set by evaluateRule
				MatchedValue: "", // Will be set by evaluateRule
				Confidence:   rule.Action.Confidence,
				MatchedAt:    time.Now(),
			}
			matches = append(matches, match)
		}
	}
	
	return matches
}

func (m *Manager) evaluateRule(rule *types.DetectionRule, candidate *types.DeviceDetectionCandidate) bool {
	// All conditions must match for the rule to match
	for _, condition := range rule.Conditions {
		if !m.evaluateCondition(&condition, candidate) {
			return false
		}
	}
	return len(rule.Conditions) > 0
}

func (m *Manager) evaluateCondition(condition *types.DetectionCondition, candidate *types.DeviceDetectionCandidate) bool {
	var fieldValue string
	
	switch condition.Type {
	case "mac_prefix":
		fieldValue = candidate.MacAddress
	case "hostname_pattern":
		fieldValue = candidate.Hostname
	case "manufacturer":
		fieldValue = candidate.Manufacturer
	case "dhcp_vendor":
		fieldValue = candidate.DHCPVendor
	case "user_agent":
		fieldValue = candidate.UserAgent
	default:
		return false
	}
	
	matched := false
	
	switch condition.Operator {
	case "equals":
		matched = strings.EqualFold(fieldValue, condition.Value)
	case "contains":
		matched = strings.Contains(strings.ToLower(fieldValue), strings.ToLower(condition.Value))
	case "starts_with":
		matched = strings.HasPrefix(strings.ToUpper(fieldValue), strings.ToUpper(condition.Value))
	case "regex":
		if regex, err := regexp.Compile(condition.Value); err == nil {
			matched = regex.MatchString(fieldValue)
		}
	case "in_list":
		values := strings.Split(condition.Value, ",")
		for _, value := range values {
			if strings.EqualFold(strings.TrimSpace(value), fieldValue) {
				matched = true
				break
			}
		}
	}
	
	if condition.Negate {
		matched = !matched
	}
	
	return matched
}

func (m *Manager) applyDetectionAction(identity *types.DeviceIdentity, action *types.DetectionAction, candidate *types.DeviceDetectionCandidate) {
	if action.SetFriendlyName != "" {
		identity.FriendlyName = action.SetFriendlyName
	}
	if action.SetDeviceType != "" {
		identity.DeviceType = action.SetDeviceType
	}
	if action.SetManufacturer != "" {
		identity.Manufacturer = action.SetManufacturer
	}
	if action.SetModel != "" {
		identity.Model = action.SetModel
	}
	if action.SetLocation != "" {
		identity.Location = action.SetLocation
	}
	if action.SetOwner != "" {
		identity.Owner = action.SetOwner
	}
	if action.SetCategory != "" {
		identity.Category = action.SetCategory
	}
	if len(action.AddTags) > 0 {
		identity.Tags = append(identity.Tags, action.AddTags...)
	}
	
	// Use manufacturer from candidate if not set by action
	if identity.Manufacturer == "" && candidate.Manufacturer != "" {
		identity.Manufacturer = candidate.Manufacturer
	}
}

func (m *Manager) getRulePriority(ruleID string) int {
	if rule, exists := m.detectionRules[ruleID]; exists {
		return rule.Priority
	}
	return 0
}

func (m *Manager) updateStats() {
	go func() {
		stats, err := m.storage.GetIdentityStats()
		if err != nil {
			log.Printf("Failed to update identity stats: %v", err)
			return
		}
		
		m.statsMutex.Lock()
		m.stats = stats
		m.statsMutex.Unlock()
	}()
}

// initializeDefaultRules moved to manager_rules.go
func (m *Manager) initializeDefaultRulesOld() {
	defaultRules := []types.DetectionRule{
		{
			ID:          "apple-devices",
			Name:        "Apple Devices",
			Description: "Detect Apple devices by MAC prefix",
			Enabled:     true,
			Priority:    100,
			Conditions: []types.DetectionCondition{
				{Type: "mac_prefix", Operator: "starts_with", Value: "00:03:93,00:05:02,00:0A:95,00:11:24,00:13:CE,00:14:51,00:16:CB,00:17:F2,00:19:E3,00:1B:63,00:1E:C2,00:21:E9,00:23:12,00:23:DF,00:24:36,00:25:00,00:25:4B,00:25:BC,00:26:08,00:26:4A,00:26:B0,00:26:BB,04:0C:CE,04:15:52,04:69:F2,04:DB:56,04:E5:36,04:F1:3E,04:F7:E4,08:74:02,08:96:D7,0C:3E:9F,0C:4D:E9,0C:74:C2,0C:77:1A,10:40:F3,10:9A:DD,10:DD:B1,14:10:9F,14:20:5E,14:5A:05,14:7D:DA,14:BD:61,18:34:51,18:65:90,18:AF:61,1C:1A:C0,1C:36:BB,1C:AB:A7,20:32:33,20:3C:AE,20:A2:E4,20:AB:37,20:C9:D0,24:A0:74,24:AB:81,24:F0:94,24:F6:77,28:37:37,28:6A:BA,28:A0:2B,28:E0:2C,28:E7:CF,2C:1F:23,2C:3E:CF,2C:B4:3A,30:10:B3,30:35:AD,30:63:6B,30:90:AB,30:F7:0D,34:12:98,34:15:9E,34:36:3B,34:A3:95,34:AB:37,34:C0:59,34:E2:FD,38:0F:4A,38:B5:4D,3C:15:C2,3C:2E:F9,40:30:04,40:33:1A,40:A6:D9,40:B3:95,40:CC:A8,44:00:10,44:2A:60,44:4C:0C,44:D8:84,48:43:7C,48:74:6E,48:A1:95,48:BF:6B,4C:1A:3D,4C:3C:16,4C:7C:5F,4C:8D:79,4C:B1:99,50:ED:3C,54:26:96,54:72:C1,54:AE:27,54:E4:3A,58:1F:AA,58:40:4E,58:55:CA,5C:59:48,5C:95:AE,5C:96:9D,5C:F9:38,60:03:08,60:33:4B,60:5B:B4,60:C5:47,60:F8:1D,60:FA:CD,64:20:0C,64:B0:A6,64:E6:82,68:15:90,68:26:CC,68:5B:35,68:96:7B,68:A8:6D,68:AB:1E,68:D9:3C,6C:40:08,6C:70:9F,6C:8D:C1,6C:94:66,6C:AD:F8,70:11:24,70:56:81,70:73:CB,70:CD:60,70:DE:E2,74:1B:B2,74:E2:F5,78:02:F8,78:31:C1,78:4F:43,78:67:D0,78:7B:8A,78:A3:E4,78:CA:39,78:D7:5F,7C:01:0A,7C:11:CB,7C:6D:62,7C:C3:A1,7C:C5:37,7C:D1:C3,80:00:6E,80:3E:75,80:92:9F,80:E6:50,84:38:35,84:78:8B,84:85:06,84:FC:FE,88:1D:FC,88:53:95,88:63:DF,8C:29:37,8C:58:77,8C:7A:E1,8C:85:90,8C:8E:F2,90:2E:16,90:8D:6C,90:B0:ED,90:B2:1F,94:35:0A,94:94:26,94:E9:6A,94:F6:A3,98:03:D8,98:5A:EB,98:B8:E3,98:FE:94,9C:04:EB,9C:20:7B,9C:29:3F,9C:35:EB,9C:84:BF,9C:F3:87,A0:99:9B,A0:D7:95,A4:D1:8C,A4:F1:E8,A8:20:66,A8:51:AB,A8:66:7F,A8:96:8A,A8:FA:D8,AC:1F:74,AC:29:3A,AC:3C:0B,AC:61:EA,AC:7F:3E,AC:87:A3,AC:BC:32,B0:65:BD,B0:CA:68,B4:18:D1,B4:F0:AB,B4:F6:1C,B8:09:8A,B8:17:C2,B8:53:AC,B8:63:BC,B8:78:2E,B8:8D:12,B8:C7:5D,B8:E8:56,B8:F6:B1,BC:3B:AF,BC:52:B7,BC:67:1C,BC:93:5C,BC:F5:AC,C0:84:7A,C4:2C:03,C8:21:58,C8:2A:14,C8:33:4B,C8:69:CD,C8:89:F3,C8:B5:B7,C8:BC:C8,C8:E0:EB,CC:08:8D,CC:25:EF,CC:29:F5,D0:23:DB,D0:33:11,D0:81:7A,D4:90:9C,D4:A3:3D,D8:30:62,D8:A2:5E,D8:BB:2C,DC:0C:5C,DC:2B:2A,DC:37:45,DC:3A:5E,DC:A9:04,DC:AB:25,E0:5F:45,E0:B5:2D,E0:B9:A5,E0:C9:7A,E4:25:E7,E4:CE:8F,E8:80:2E,E8:B2:AC,EC:35:86,EC:8A:4C,F0:18:98,F0:1D:BC,F0:D1:A9,F0:DB:E2,F0:DC:E2,F0:F6:1C,F4:0F:24,F4:37:B7,F4:5C:89,F4:F1:5A,F4:F9:51,F8:16:54,F8:27:93,F8:2F:A8,F8:D0:27,FC:25:3F,FC:2A:9C"},
				},
			},
			Action: types.DetectionAction{
				SetDeviceType:   "apple_device",
				SetManufacturer: "Apple",
				Confidence:      0.9,
			},
		},
		{
			ID:          "samsung-devices",
			Name:        "Samsung Devices",
			Description: "Detect Samsung devices by MAC prefix",
			Enabled:     true,
			Priority:    90,
			Conditions: []types.DetectionCondition{
				{Type: "mac_prefix", Operator: "starts_with", Value: "00:08:22"},
			},
			Action: types.DetectionAction{
				SetDeviceType:   "samsung_device",
				SetManufacturer: "Samsung",
				Confidence:      0.85,
			},
		},
	}
	
	for i := range defaultRules {
		if err := m.AddDetectionRule(&defaultRules[i]); err != nil {
			log.Printf("Failed to add default detection rule %s: %v", defaultRules[i].ID, err)
		}
	}
}